using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Web.Mvc;
using ISIC.Entities;
using ISIC.Services;
using MPBA.DataAccess;

namespace ISIC.Infrastructure
{
    public class MustBeGermanAttribute : ValidationAttribute, IClientValidatable
    {
        public MustBeGermanAttribute(int wordCount)
            : base("Too many words in {0}")
        {
            WordCount = wordCount;
        }

        public int WordCount { get; set; }

        protected override ValidationResult IsValid(
            object value,
            ValidationContext validationContext)
        {

            if (value != null)
            {
                var wordCount = value.ToString().Split(' ').Length;
                if (wordCount > WordCount)
                {
                    return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
                }
            }
            return ValidationResult.Success;
        }

        public IEnumerable<ModelClientValidationRule> GetClientValidationRules(ModelMetadata metadata, ControllerContext context)
        {
            var rule = new ModelClientValidationRule();
            rule.ErrorMessage = FormatErrorMessage(metadata.GetDisplayName());
            rule.ValidationParameters.Add("wordcount", WordCount);
            rule.ValidationType = "maxwords";
            yield return rule;
        }
    }
}


public sealed class IsDateAfterAttribute : ValidationAttribute, IClientValidatable
{
    private readonly string testedPropertyName;
    private readonly bool allowEqualDates;

    public IsDateAfterAttribute(string testedPropertyName, bool allowEqualDates = false)
    {
        this.testedPropertyName = testedPropertyName;
        this.allowEqualDates = allowEqualDates;
    }

    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        var propertyTestedInfo = validationContext.ObjectType.GetProperty(this.testedPropertyName);
        if (propertyTestedInfo == null)
        {
            return new ValidationResult(string.Format("unknown property {0}", this.testedPropertyName));
        }

        var propertyTestedValue = propertyTestedInfo.GetValue(validationContext.ObjectInstance, null);
        DateTime d;
        if (value == null || DateTime.TryParse(value.ToString(), out d)==false)
        {
            return ValidationResult.Success;
        }

        if (propertyTestedValue == null || DateTime.TryParse(propertyTestedValue.ToString(), out d) == false)
        {
            return ValidationResult.Success;
        }
        DateTime valor = DateTime.ParseExact(value.ToString(), "dd/MM/yyyy", CultureInfo.InvariantCulture);
        DateTime valorTesteado = DateTime.ParseExact(propertyTestedValue.ToString(), "dd/MM/yyyy",
            CultureInfo.InvariantCulture);
        // Compare values
        if (valor >= valorTesteado)
        {
            if (this.allowEqualDates && value == propertyTestedValue)
            {
                return ValidationResult.Success;
            }
            else if (valor > valorTesteado)
            {
                return ValidationResult.Success;
            }
        }

        return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
    }

    public IEnumerable<ModelClientValidationRule> GetClientValidationRules(ModelMetadata metadata,
        ControllerContext context)
    {
        var rule = new ModelClientValidationRule
        {
            ErrorMessage = this.ErrorMessageString,
            ValidationType = "isdateafter"
        };
        rule.ValidationParameters["propertytested"] = this.testedPropertyName;
        rule.ValidationParameters["allowequaldates"] = this.allowEqualDates;
        yield return rule;
    }
}


public sealed class IsDateBeforeAttribute : ValidationAttribute, IClientValidatable
{
    private readonly string testedPropertyName;
    private readonly bool allowEqualDates;

    public IsDateBeforeAttribute(string testedPropertyName, bool allowEqualDates = false)
    {
        this.testedPropertyName = testedPropertyName;
        this.allowEqualDates = allowEqualDates;
    }

    protected override ValidationResult IsValid(object value, ValidationContext validationContext)
    {
        var propertyTestedInfo = validationContext.ObjectType.GetProperty(this.testedPropertyName);
        if (propertyTestedInfo == null)
        {
            return new ValidationResult(string.Format("unknown property {0}", this.testedPropertyName));
        }

        var propertyTestedValue = propertyTestedInfo.GetValue(validationContext.ObjectInstance, null);
        DateTime d;
        if (value == null || DateTime.TryParse(value.ToString(), out d) == false)
        {
            return ValidationResult.Success;
        }

        if (propertyTestedValue == null || DateTime.TryParse(propertyTestedValue.ToString(), out d) == false)
        {
            return ValidationResult.Success;
        }
        DateTime valorTesteado = DateTime.ParseExact(value.ToString(), "dd/MM/yyyy", CultureInfo.InvariantCulture);
        DateTime valor = DateTime.ParseExact(propertyTestedValue.ToString(), "dd/MM/yyyy",
            CultureInfo.InvariantCulture);
        // Compare values
        if (valor >= valorTesteado)
        {
            if (this.allowEqualDates && value == propertyTestedValue)
            {
                return ValidationResult.Success;
            }
            else if (valor > valorTesteado)
            {
                return ValidationResult.Success;
            }
        }

        return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
    }

    public IEnumerable<ModelClientValidationRule> GetClientValidationRules(ModelMetadata metadata,
        ControllerContext context)
    {
        var rule = new ModelClientValidationRule
        {
            ErrorMessage = this.ErrorMessageString,
            ValidationType = "isdatebefore"
        };
        rule.ValidationParameters["propertytested"] = this.testedPropertyName;
        rule.ValidationParameters["allowequaldates"] = this.allowEqualDates;
        yield return rule;
    }
}



public class LetraCodigoBarrasAttribute : ValidationAttribute,
    IClientValidatable
{

    protected override ValidationResult IsValid(
        object value,
        ValidationContext validationContext)
    {
        if (value != null)
        {
            string CodigoBarras = value.ToString();
            string letra = BuscarLetra(CodigoBarras);

            if (letra != CodigoBarras.Substring(12, 1).ToUpper())
            {
                return new ValidationResult(string.Format("Letra del Código de Barras incorrecta. Debería ser: {0}", letra));

            }
        }
        return ValidationResult.Success;
    }

    public IEnumerable<ModelClientValidationRule> GetClientValidationRules(
        ModelMetadata metadata, ControllerContext context)
    {
        var rule = new ModelClientValidationRule();
        //rule.ErrorMessage = FormatErrorMessage(metadata.GetDisplayName());
        //rule.ValidationParameters.Add("letra", CodigoBarras);
        rule.ValidationType = "letracodbarras";
        yield return rule;
    }

    private string BuscarLetra(string cb)
    {
        var Codigo = "";
        var i = 0;
        var j = 0;
        var letra = "";
        var expo = new int[] { 0, 1, 2, 4, 8 };
        if (cb.Count() != 13)
            return "";
        else
            Codigo = cb.Substring(0, 12);
        int n;
        if (int.TryParse(Codigo, out n))
            return "";
        var Suma = 0;
        for (i = 1; i <= 3; i++)
        {
            for (j = 1; j <= 4; j++)
            {
                Suma += (Convert.ToInt32((Codigo.Substring((i - 1) * 4 + j - 1, 1))) + 48) * expo[j];
            }
        }
        letra = "ABCDEFGHIJKMNPRSTUVWXYZ".Substring(((Suma % 23)), 1);
        letra = letra.ToUpper();
        return letra;
    }
}